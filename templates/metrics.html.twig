{# templates/lucky_number.html.twig #}

{% extends "base.html.twig" %}

{% block title %}Metrics{% endblock %}

{% block body %}
    <h1>Metrics</h1>
    <p>Welcome to my metrics page.</p>
<div class="wrapper">    
	<div class="report-sidebar">
		<ul>
		    <li><a href="#introduktion">Introduktion</a></li>
		    <li><a href="#Phpmetrics">Phpmetrics</a></li>
		    <li><a href="#Scrutinizer">Scrutinizer</a></li>
		    <li><a href="#Förbättringar">Förbättringar</a></li>
		    <li><a href="#Diskussion">Diskussion</a></li>
		</ul>
	</div>
	<div class="report-content">
	
		<h2 id = "introduktion">Introduktion</h2>
		{% apply markdown_to_html %}
Det finns sex C:er som kan påverka kodens kvalitet, och de är:
1. __Codestyle__ handlar mest om storlek av koden, dvs. hur många rader kod varje klass eller metod innehåller inkl. kommentarerna eller exkl. kommentarerna. Det är viktigt att hålla koden inom en rimlig storlek, annars kan det bli svårt att vidareutveckla, underhålla och felsöka. I min applikation är den största klassen just nu APIController som har 195 rader kod enligt Scrutinizers analys, medan klassen BookRepository har 5 rader kod som är den minsta klassen. Min APIController-klass är just nu lagom stor, men om den ska bli ännu större i framtiden, ska man överväga att dela koden till olika klasser, så att det bli lättare för att göra underhåll.

2. __Coverage__ handlar om hur mycket kod är täckt av testkod. Man kan mäta kodtäckning för hela applikationen, för varje klass, och för varje metod i klassen. I min applikation har jag skrivit testkod för klasserna som var skapade för kortspel, därför är alla dessa klasser 100% täckta av testkod, medan de andra klasserna är 0% täckta av testkod eftersom jag inte har skrivit någon testkod för dem. Högre kodtäckning innebär att applikationen, klassen eller metoden är väl-testad, medan lägre kodtäckning kan innebär att det inte är säkert att koden har bra kvalitet, dvs koden KAN ha sämre kvalitet.

3. __Complexity__ indikerar hur komplex koden är. Högre värde innebär att koden är mer komplex och lägre värde tvärtom. I min klassen är Game-klassen den mesta komplex bland alla, och det innebär att denna klass jämfört med andra klasser kan vara svårare att underhålla och vidareutveckla.

4. __Cohesion__ kallas också för Lack of cohesion of methods (LCOM) och den indikerar hur bra olika metoder i en klass sitter ihop. Högre värde innebär att klassen kan ha för många ansvar och kan därför delas till olika mindre klasser, som APIController i min applikation som har det högsta värdet 8 bland alla klasser; medan lägre värde innebär att metoderna i klassen sitter ihop och är fokuserade med enkla funktioner, så de verkligen tillhör samma klass.

5. __Coupling__ har två typer "afferent coupling (AC)" som visar hur många klasser är påverkade av en given klass, och "efferent coupling (EC) som visar hur många klasser en given klass få effekter från. Klassen CardHand i min applikation har AC-värde på 3 och EC-värde på 1, så det innebär att tre andra klasser använder och är beroende av Card, och Card använder och är beroende av en annan klass. 

6. __CRAP__ står för "Change Risk Analyzer and Predictor" är en uppskattning av hur mycket arbete som krävs för att ta itu med taskiga metoder. Den påverkas av hur komplex en metod är och hur många testfall som täcker metoden. Man kan genom att öka testfall minska CRAP-värdet. Så länge man har tillräckligt med testfall, går det bra att ha komplex metoder. I min applikation har de php-filerna som är Controller högsta CRAP-värden just nu enligt PHPUnits dashboard, eftersom de inte alls täcks av testfall (0% coverage).


        {% endapply %}
        
		<h2 id = "Phpmetrics">Phpmetrics</h2>
		{% apply markdown_to_html %}
analysera dess rapport för din kod. Använd mätvärdena för att hitta flaskhalsar och svaga punkter i din kod (minst 3 stycken). Du vill hitta kod som har förbättringspotential. Visualisera med någon representativ bild från rapporten.
        {% endapply %}
        
		<h2 id = "Scrutinizer">Scrutinizer</h2>
		{% apply markdown_to_html %}
analysera dess rapport för din kod. Gör på samma sätt som du gjorde med Phpmetrics.

[![Build Status](https://scrutinizer-ci.com/g/guschenxi/BTH_DV1608_mvc/badges/build.png?b=master)](https://scrutinizer-ci.com/g/guschenxi/BTH_DV1608_mvc/build-status/master)
[![Code Coverage](https://scrutinizer-ci.com/g/guschenxi/BTH_DV1608_mvc/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/guschenxi/BTH_DV1608_mvc/?branch=master)
[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/guschenxi/BTH_DV1608_mvc/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/guschenxi/BTH_DV1608_mvc/?branch=master)

Inkludera klickbara Scrutinizer badges i din rapport för build, coverage och quality.
Placera samma badges i din README.md.

I ovan analys så kopplar du dina “findings” till 6C. Använd gärna något ytterligare mättal som du finner relevant och intressant.
        {% endapply %}
        
		<h2 id = "Förbättringar">Förbättringar</h2>
		{% apply markdown_to_html %}
du väljer minst 3 förbättringar som du vill göra med din kod (gärna fler).

Exempel på förbättringar kan vara:

1. Fixa issues
2. Öka kodtäckning
3. Fokusera på kvalitetsindex i Scrutinizer
4. Minska komplexiteten i class/metod
Börja med att skriva om förbättringarna, vad du tänker göra, varför du väljer dem och hur du tror det kommer påverka mätvärdena för kvalitet.

Implementera sedan förbättringarna.
Analysera därefter rapporterna från phpmetrics och Scrutinizer och notera de nya mätvärdena.
Gör det tydligt hur mätvärdena såg ut innan och efter dina förbättringar.

        {% endapply %}
        
		<h2 id = "Diskussion">Diskussion</h2>
		{% apply markdown_to_html %}
		du diskuterar kort kring det du nyss gjort.

Kan man aktivt jobba med kodkvalitet och “clean code” på detta sättet?
Finns det fördelar och kanske nackdelar?
Ser du andra möjligheter att jobba mot “clean code”?
        {% endapply %}
	</div>
</div>
{% endblock %}
